#version 450

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer InBuffer {
  float values[];
} in_buffer;

layout(set = 0, binding = 1) writeonly buffer OutBuffer {
  float values[];
} out_buffer;

layout(push_constant) uniform PushConstants {
  uint n_rows;
  uint axis_size;
} params;

shared float s_max[256];
shared float s_sum[256];

void main() {
  uint row = gl_WorkGroupID.x;
  uint lane = gl_LocalInvocationID.x;
  if (row >= params.n_rows || params.axis_size == 0u) {
    return;
  }

  uint base = row * params.axis_size;

  float local_max = -3.4028235e38;
  for (uint i = lane; i < params.axis_size; i += 256u) {
    local_max = max(local_max, in_buffer.values[base + i]);
  }

  s_max[lane] = local_max;
  barrier();

  for (uint stride = 128u; stride > 0u; stride >>= 1u) {
    if (lane < stride) {
      s_max[lane] = max(s_max[lane], s_max[lane + stride]);
    }
    barrier();
  }

  float row_max = s_max[0];
  if (isinf(row_max)) {
    if (lane == 0u) {
      out_buffer.values[row] = row_max;
    }
    return;
  }

  float local_sum = 0.0;
  for (uint i = lane; i < params.axis_size; i += 256u) {
    local_sum += exp(in_buffer.values[base + i] - row_max);
  }

  s_sum[lane] = local_sum;
  barrier();

  for (uint stride = 128u; stride > 0u; stride >>= 1u) {
    if (lane < stride) {
      s_sum[lane] += s_sum[lane + stride];
    }
    barrier();
  }

  if (lane == 0u) {
    out_buffer.values[row] = log(s_sum[0]) + row_max;
  }
}
