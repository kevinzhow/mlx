#version 450

// Stage 2 for prefill SDPA split-k:
// reduce partial tuples (o_i, m_i, l_i) into final bf16 output.
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer PartialOBuffer {
  float values[];
} partial_o_buffer;

layout(set = 0, binding = 1) readonly buffer PartialMBuffer {
  float values[];
} partial_m_buffer;

layout(set = 0, binding = 2) readonly buffer PartialLBuffer {
  float values[];
} partial_l_buffer;

layout(set = 0, binding = 3) buffer OutBuffer {
  uint words[];
} out_buffer;

layout(push_constant) uniform PushConstants {
  uint batch_size;
  uint n_q_heads;
  uint q_len;
  uint v_dim;
  uint split_k;
} params;

const uint WG_SIZE = 64u;

shared float reduce_buf[WG_SIZE];
shared float final_m;
shared float final_l;
shared float out_accum[256];

uint f32_to_bf16(float value) {
  uint bits = floatBitsToUint(value);
  uint lsb = (bits >> 16u) & 1u;
  uint rounding_bias = 0x7FFFu + lsb;
  return (bits + rounding_bias) >> 16u;
}

void store_out(uint elem_idx, float value) {
  uint word_idx = elem_idx >> 1u;
  uint packed = out_buffer.words[word_idx];
  uint bf16_val = f32_to_bf16(value) & 0xFFFFu;
  if ((elem_idx & 1u) == 0u) {
    packed = (packed & 0xFFFF0000u) | bf16_val;
  } else {
    packed = (packed & 0x0000FFFFu) | (bf16_val << 16u);
  }
  out_buffer.words[word_idx] = packed;
}

void main() {
  uint row = gl_WorkGroupID.x;
  uint lane = gl_LocalInvocationID.x;

  uint n_rows = params.batch_size * params.n_q_heads * params.q_len;
  if (row >= n_rows || params.v_dim == 0u || params.v_dim > 256u ||
      params.split_k == 0u) {
    return;
  }

  uint row_split_base = row * params.split_k;

  // Pass 1: M = max_i(m_i)
  float local_max = -3.4028235e38;
  for (uint part = lane; part < params.split_k; part += WG_SIZE) {
    float m = partial_m_buffer.values[row_split_base + part];
    local_max = max(local_max, m);
  }
  reduce_buf[lane] = local_max;
  barrier();
  for (uint stride = WG_SIZE / 2u; stride > 0u; stride >>= 1u) {
    if (lane < stride) {
      reduce_buf[lane] = max(reduce_buf[lane], reduce_buf[lane + stride]);
    }
    barrier();
  }
  if (lane == 0u) {
    final_m = reduce_buf[0];
  }
  barrier();

  // Pass 2: L = sum_i(exp(m_i - M) * l_i)
  float local_l = 0.0;
  for (uint part = lane; part < params.split_k; part += WG_SIZE) {
    float m = partial_m_buffer.values[row_split_base + part];
    float l = partial_l_buffer.values[row_split_base + part];
    if (l > 0.0) {
      local_l += exp(m - final_m) * l;
    }
  }
  reduce_buf[lane] = local_l;
  barrier();
  for (uint stride = WG_SIZE / 2u; stride > 0u; stride >>= 1u) {
    if (lane < stride) {
      reduce_buf[lane] += reduce_buf[lane + stride];
    }
    barrier();
  }
  if (lane == 0u) {
    final_l = reduce_buf[0];
  }
  barrier();

  // Pass 3: O = (sum_i(exp(m_i - M) * o_i)) / L
  for (uint dv = lane; dv < params.v_dim; dv += WG_SIZE) {
    float acc = 0.0;
    for (uint part = 0u; part < params.split_k; ++part) {
      uint part_idx = row_split_base + part;
      float m = partial_m_buffer.values[part_idx];
      float coeff = exp(m - final_m);
      acc += coeff * partial_o_buffer.values[part_idx * params.v_dim + dv];
    }
    if (final_l > 0.0) {
      acc /= final_l;
    } else {
      acc = 0.0;
    }
    out_accum[dv] = acc;
  }
  barrier();

  uint out_base = row * params.v_dim;
  if ((params.v_dim & 1u) == 0u) {
    uint out_word_base = out_base >> 1u;
    uint out_word_count = params.v_dim >> 1u;
    for (uint w = lane; w < out_word_count; w += WG_SIZE) {
      uint dv = w << 1u;
      uint lo = f32_to_bf16(out_accum[dv]) & 0xFFFFu;
      uint hi = f32_to_bf16(out_accum[dv + 1u]) & 0xFFFFu;
      out_buffer.words[out_word_base + w] = lo | (hi << 16u);
    }
  } else if (lane == 0u) {
    for (uint dv = 0u; dv < params.v_dim; ++dv) {
      store_out(out_base + dv, out_accum[dv]);
    }
  }
}
