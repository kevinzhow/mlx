#version 450

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer BufferA {
  uint words[];
} buffer_a;

layout(set = 0, binding = 1) readonly buffer BufferB {
  uint words[];
} buffer_b;

layout(set = 0, binding = 2) writeonly buffer BufferC {
  uint words[];
} buffer_c;

layout(push_constant) uniform PushConstants {
  uint size;
} params;

float bf16_to_f32(uint bf16_bits) {
  return uintBitsToFloat((bf16_bits & 0xFFFFu) << 16u);
}

uint f32_to_bf16(float value) {
  uint bits = floatBitsToUint(value);
  uint lsb = (bits >> 16u) & 1u;
  uint rounding_bias = 0x7FFFu + lsb;
  return (bits + rounding_bias) >> 16u;
}

float load_bf16_from_word(uint packed, uint elem_idx) {
  uint bf16_bits = ((elem_idx & 1u) == 0u) ? (packed & 0xFFFFu)
                                           : (packed >> 16u);
  return bf16_to_f32(bf16_bits);
}

void main() {
  uint word_idx = gl_GlobalInvocationID.x;
  uint elem0 = word_idx * 2u;
  if (elem0 >= params.size) {
    return;
  }

  float scalar = bf16_to_f32(buffer_b.words[0] & 0xFFFFu);
  uint a_word = buffer_a.words[word_idx];

  float a0 = load_bf16_from_word(a_word, elem0);
  uint out_word = f32_to_bf16(a0 - scalar) & 0xFFFFu;

  uint elem1 = elem0 + 1u;
  if (elem1 < params.size) {
    float a1 = load_bf16_from_word(a_word, elem1);
    out_word |= (f32_to_bf16(a1 - scalar) & 0xFFFFu) << 16u;
  }

  buffer_c.words[word_idx] = out_word;
}
