#version 450
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_arithmetic : require

// Decode-specialized QMM kernel for rows==1 and groups_per_col==8.
// One workgroup computes two packed output words (4 bf16 values) to reuse
// x-buffer loads across neighboring columns.
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer XBuffer {
  uint words[];
} x_buffer;

layout(set = 0, binding = 1) readonly buffer WBuffer {
  uint words[];
} w_buffer;

layout(set = 0, binding = 2) readonly buffer ScaleBuffer {
  uint words[];
} scale_buffer;

layout(set = 0, binding = 3) readonly buffer BiasBuffer {
  uint words[];
} bias_buffer;

layout(set = 0, binding = 4) writeonly buffer OutBuffer {
  uint words[];
} out_buffer;

layout(push_constant) uniform PushConstants {
  uint out_elems;
  uint n;
  uint k;
  uint groups_per_col;
  uint w_words_per_col;
} params;

shared float subgroup_reduce00[64];
shared float subgroup_reduce01[64];
shared float subgroup_reduce10[64];
shared float subgroup_reduce11[64];
shared float deq00_cache[8u * 16u];
shared float deq01_cache[8u * 16u];
shared float deq10_cache[8u * 16u];
shared float deq11_cache[8u * 16u];

float bf16_to_f32(uint bf16_bits) {
  return uintBitsToFloat((bf16_bits & 0xFFFFu) << 16u);
}

uint f32_to_bf16(float value) {
  uint bits = floatBitsToUint(value);
  uint lsb = (bits >> 16u) & 1u;
  uint rounding_bias = 0x7FFFu + lsb;
  return (bits + rounding_bias) >> 16u;
}

float load_bf16_from_packed(uint packed, uint elem_idx) {
  uint bf16_bits = ((elem_idx & 1u) == 0u) ? (packed & 0xFFFFu)
                                           : (packed >> 16u);
  return bf16_to_f32(bf16_bits);
}

void main() {
  const uint lane = gl_LocalInvocationID.x;
  const uint out_words = (params.out_elems + 1u) / 2u;
  const uint out_word_base = gl_WorkGroupID.x * 2u;
  if (out_word_base >= out_words) {
    return;
  }

  const uint out_word_0 = out_word_base;
  const uint out_word_1 = out_word_base + 1u;
  const bool has_out_word_1 = out_word_1 < out_words;

  const uint out_elem_00 = out_word_0 * 2u;
  const uint out_elem_01 = out_elem_00 + 1u;
  const bool has_out_01 = out_elem_01 < params.out_elems;

  const uint out_elem_10 = out_word_1 * 2u;
  const uint out_elem_11 = out_elem_10 + 1u;
  const bool has_out_10 = has_out_word_1;
  const bool has_out_11 = has_out_word_1 && (out_elem_11 < params.out_elems);

  if (lane < 8u) {
    const uint g = lane;
    const uint base = g * 16u;

    const uint scale_bias_idx00 = out_elem_00 * 8u + g;
    const float scale00 = load_bf16_from_packed(
        scale_buffer.words[scale_bias_idx00 >> 1u], scale_bias_idx00);
    const float bias00 = load_bf16_from_packed(
        bias_buffer.words[scale_bias_idx00 >> 1u], scale_bias_idx00);
    for (uint q = 0u; q < 16u; ++q) {
      deq00_cache[base + q] = scale00 * float(q) + bias00;
    }

    if (has_out_01) {
      const uint scale_bias_idx01 = out_elem_01 * 8u + g;
      const float scale01 = load_bf16_from_packed(
          scale_buffer.words[scale_bias_idx01 >> 1u], scale_bias_idx01);
      const float bias01 = load_bf16_from_packed(
          bias_buffer.words[scale_bias_idx01 >> 1u], scale_bias_idx01);
      for (uint q = 0u; q < 16u; ++q) {
        deq01_cache[base + q] = scale01 * float(q) + bias01;
      }
    }

    if (has_out_10) {
      const uint scale_bias_idx10 = out_elem_10 * 8u + g;
      const float scale10 = load_bf16_from_packed(
          scale_buffer.words[scale_bias_idx10 >> 1u], scale_bias_idx10);
      const float bias10 = load_bf16_from_packed(
          bias_buffer.words[scale_bias_idx10 >> 1u], scale_bias_idx10);
      for (uint q = 0u; q < 16u; ++q) {
        deq10_cache[base + q] = scale10 * float(q) + bias10;
      }
    }

    if (has_out_11) {
      const uint scale_bias_idx11 = out_elem_11 * 8u + g;
      const float scale11 = load_bf16_from_packed(
          scale_buffer.words[scale_bias_idx11 >> 1u], scale_bias_idx11);
      const float bias11 = load_bf16_from_packed(
          bias_buffer.words[scale_bias_idx11 >> 1u], scale_bias_idx11);
      for (uint q = 0u; q < 16u; ++q) {
        deq11_cache[base + q] = scale11 * float(q) + bias11;
      }
    }
  }
  barrier();

  float partial00 = 0.0;
  float partial01 = 0.0;
  float partial10 = 0.0;
  float partial11 = 0.0;
  for (uint unit = lane; unit < 128u; unit += 64u) {
    const uint g = unit >> 4u;
    const uint ww = unit & 0xFu;
    const uint deq_base = g * 16u;

    const uint w_word_idx00 =
        out_elem_00 * params.w_words_per_col + g * 16u + ww;
    const uint wi00 = w_buffer.words[w_word_idx00];
    uint wi01 = 0u;
    if (has_out_01) {
      const uint w_word_idx01 =
          out_elem_01 * params.w_words_per_col + g * 16u + ww;
      wi01 = w_buffer.words[w_word_idx01];
    }
    uint wi10 = 0u;
    if (has_out_10) {
      const uint w_word_idx10 =
          out_elem_10 * params.w_words_per_col + g * 16u + ww;
      wi10 = w_buffer.words[w_word_idx10];
    }
    uint wi11 = 0u;
    if (has_out_11) {
      const uint w_word_idx11 =
          out_elem_11 * params.w_words_per_col + g * 16u + ww;
      wi11 = w_buffer.words[w_word_idx11];
    }

    const uint x_word_base = g * 64u + ww * 4u;
    for (uint t = 0u; t < 4u; ++t) {
      const uint x_packed = x_buffer.words[x_word_base + t];
      const float x0 = load_bf16_from_packed(x_packed, 0u);
      const float x1 = load_bf16_from_packed(x_packed, 1u);
      const uint shift = t * 8u;

      const uint q000 = (wi00 >> shift) & 0xFu;
      const uint q001 = (wi00 >> (shift + 4u)) & 0xFu;
      partial00 += x0 * deq00_cache[deq_base + q000];
      partial00 += x1 * deq00_cache[deq_base + q001];

      if (has_out_01) {
        const uint q010 = (wi01 >> shift) & 0xFu;
        const uint q011 = (wi01 >> (shift + 4u)) & 0xFu;
        partial01 += x0 * deq01_cache[deq_base + q010];
        partial01 += x1 * deq01_cache[deq_base + q011];
      }
      if (has_out_10) {
        const uint q100 = (wi10 >> shift) & 0xFu;
        const uint q101 = (wi10 >> (shift + 4u)) & 0xFu;
        partial10 += x0 * deq10_cache[deq_base + q100];
        partial10 += x1 * deq10_cache[deq_base + q101];
      }
      if (has_out_11) {
        const uint q110 = (wi11 >> shift) & 0xFu;
        const uint q111 = (wi11 >> (shift + 4u)) & 0xFu;
        partial11 += x0 * deq11_cache[deq_base + q110];
        partial11 += x1 * deq11_cache[deq_base + q111];
      }
    }
  }

  const float subgroup_sum00 = subgroupAdd(partial00);
  const float subgroup_sum01 = subgroupAdd(partial01);
  const float subgroup_sum10 = subgroupAdd(partial10);
  const float subgroup_sum11 = subgroupAdd(partial11);
  if (gl_NumSubgroups == 1u) {
    if (gl_SubgroupInvocationID == 0u) {
      uint packed0 = f32_to_bf16(subgroup_sum00) & 0xFFFFu;
      if (has_out_01) {
        packed0 |= (f32_to_bf16(subgroup_sum01) & 0xFFFFu) << 16u;
      }
      out_buffer.words[out_word_0] = packed0;
      if (has_out_word_1) {
        uint packed1 = f32_to_bf16(subgroup_sum10) & 0xFFFFu;
        if (has_out_11) {
          packed1 |= (f32_to_bf16(subgroup_sum11) & 0xFFFFu) << 16u;
        }
        out_buffer.words[out_word_1] = packed1;
      }
    }
    return;
  }

  if (gl_SubgroupInvocationID == 0u) {
    subgroup_reduce00[gl_SubgroupID] = subgroup_sum00;
    subgroup_reduce01[gl_SubgroupID] = subgroup_sum01;
    subgroup_reduce10[gl_SubgroupID] = subgroup_sum10;
    subgroup_reduce11[gl_SubgroupID] = subgroup_sum11;
  }
  barrier();

  if (gl_SubgroupID == 0u) {
    const float seed00 =
        (lane < gl_NumSubgroups) ? subgroup_reduce00[lane] : 0.0;
    const float seed01 =
        (lane < gl_NumSubgroups) ? subgroup_reduce01[lane] : 0.0;
    const float seed10 =
        (lane < gl_NumSubgroups) ? subgroup_reduce10[lane] : 0.0;
    const float seed11 =
        (lane < gl_NumSubgroups) ? subgroup_reduce11[lane] : 0.0;
    const float total00 = subgroupAdd(seed00);
    const float total01 = subgroupAdd(seed01);
    const float total10 = subgroupAdd(seed10);
    const float total11 = subgroupAdd(seed11);
    if (gl_SubgroupInvocationID == 0u) {
      uint packed0 = f32_to_bf16(total00) & 0xFFFFu;
      if (has_out_01) {
        packed0 |= (f32_to_bf16(total01) & 0xFFFFu) << 16u;
      }
      out_buffer.words[out_word_0] = packed0;
      if (has_out_word_1) {
        uint packed1 = f32_to_bf16(total10) & 0xFFFFu;
        if (has_out_11) {
          packed1 |= (f32_to_bf16(total11) & 0xFFFFu) << 16u;
        }
        out_buffer.words[out_word_1] = packed1;
      }
    }
  }
}
