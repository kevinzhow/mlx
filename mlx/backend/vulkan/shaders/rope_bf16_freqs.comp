#version 450

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) readonly buffer InBuffer {
  uint words[];
} in_buffer;

layout(set = 0, binding = 1) buffer OutBuffer {
  uint words[];
} out_buffer;

layout(set = 0, binding = 2) readonly buffer FreqsBuffer {
  float values[];
} freqs_buffer;

layout(set = 0, binding = 3) readonly buffer OffsetsBuffer {
  int values[];
} offsets_buffer;

layout(push_constant) uniform PushConstants {
  uint n_rows;
  uint half_dims;
  uint row_stride;
  uint t_size;
  uint rows_per_batch;
  uint offset_is_vector;
  uint traditional;
  float scale;
  uint forward;
} params;

float bf16_to_f32(uint bf16_bits) {
  return uintBitsToFloat((bf16_bits & 0xFFFFu) << 16u);
}

uint f32_to_bf16(float value) {
  uint bits = floatBitsToUint(value);
  uint lsb = (bits >> 16u) & 1u;
  uint rounding_bias = 0x7FFFu + lsb;
  return (bits + rounding_bias) >> 16u;
}

float load_elem(uint elem_idx) {
  uint packed = in_buffer.words[elem_idx >> 1u];
  uint bf16_bits = ((elem_idx & 1u) == 0u) ? (packed & 0xFFFFu)
                                           : (packed >> 16u);
  return bf16_to_f32(bf16_bits);
}

void store_elem(uint elem_idx, float value) {
  uint word_idx = elem_idx >> 1u;
  uint packed = out_buffer.words[word_idx];
  uint bf16_val = f32_to_bf16(value) & 0xFFFFu;
  if ((elem_idx & 1u) == 0u) {
    packed = (packed & 0xFFFF0000u) | bf16_val;
  } else {
    packed = (packed & 0x0000FFFFu) | (bf16_val << 16u);
  }
  out_buffer.words[word_idx] = packed;
}

void main() {
  uint row = gl_GlobalInvocationID.x;
  if (row >= params.n_rows) {
    return;
  }

  uint offset_index =
      (params.offset_is_vector != 0u) ? (row / params.rows_per_batch) : 0u;
  int offset = offsets_buffer.values[offset_index];
  uint time_index = (params.t_size > 1u) ? (row % params.t_size) : 0u;
  float L = params.scale * float(offset + int(time_index));
  uint row_base = row * params.row_stride;

  for (uint p = 0u; p < params.half_dims; ++p) {
    float inv_freq = 1.0 / freqs_buffer.values[p];
    float theta = L * inv_freq;
    float c = cos(theta);
    float s = sin(theta);

    uint idx1;
    uint idx2;
    if (params.traditional != 0u) {
      idx1 = row_base + (p << 1u);
      idx2 = idx1 + 1u;
    } else {
      idx1 = row_base + p;
      idx2 = idx1 + params.half_dims;
    }

    float x1 = load_elem(idx1);
    float x2 = load_elem(idx2);

    float y1;
    float y2;
    if (params.forward != 0u) {
      y1 = x1 * c - x2 * s;
      y2 = x1 * s + x2 * c;
    } else {
      y1 = x2 * s + x1 * c;
      y2 = x2 * c - x1 * s;
    }

    store_elem(idx1, y1);
    store_elem(idx2, y2);
  }
}
